<img src="https://opensearch.org/assets/img/opensearch-logo-themed.svg" height="64px">

# How to run the application

## Install node_modules

To install all the dependencies, run `npm install`.

## Run the application

Run the command `node index.js`, which will start the application at `localhost:3000`.

You can also use `nodemon index.js` for auto refresh on file save.

# High Level Structure

## Overview

On the first directory level, we have all the node essentials: 

- `package.json`
- `package-lock.json`
- `index.js`, the main program
- `views`, containing the EJS files(the markdown for each page)
- `utils`, containing the developer written JS functions.
- `public`, containing the js and css files that will be given to clients and run on the client side
- `build_ymls`, a container for the cached OpenSearch distribution build yml files.
- `dashboard_build_ymls`, a container for the cached OpenSearch Dashboards distribution build yml files.
- `perf_jsons`, a container for the cached performance test json files.

## A note on `build_ymls`, `dashboard_build_ymls`, and `perf_jsons`

These folders can be empty when starting the program, and the latest 30 corresponding distribution builds ymls will be added to each of `build_ymls` and `dashboard_build_ymls`, while the latest 10 performance test jsons will be added to `perf_jsons`.

There is a function named `check_delete` that will remove the files that are not longer within the latest 30 builds or 10 performance tests.

# Each View at a High Level

## Main Page (`index.ejs`) / OpenSearch Dashboards page

This page displays the latest 30 OpenSearch distribution builds and their associated information, one on each row. They are ordered chronologically, with the newest build being the first row. There are multiple named columns in this table that give information such as: number, status(whether it is still running), result, version, start time, duration, Integ tests, BWC tests, Commits, CVEs, and Artifacts.

On every page load, it will make a Jenkins API call to get the latest 100 build numbers(it is possible to get more). Of these, the application only displays 30. The application will then loop through each of these build numbers and check if there is a folder with that number as the name: 

- If the folder doesn't exist: it will create this folder, and download the associated buildInfo.yml file and test manifest yml file from Jenkins. To download this file, it will first make a call to the Jenkins build number page to get most importantly if it is running, but also some other information like start time and version for display. If it is done running, it will download the file. 

- If the folder exists: it will attempt to read from the buildInfo.yml file to display information such as: result, version, start time, and duration. The artifact links will be generated by putting the version, build number, and architecture into a URL frame. Integ/BWC/Commits/CVEs links lead to separate pages.

The Integ/BWC and Commits links create a URL to another page on my dashboard, with parameters within the url(e.g. for integ tests: `/integ/:build_number-:version-:x64_num-:arm64_num-:dashboard`), to be able to display the required information. It allows the creation of the same link, that will lead to a specific page based on which build it belongs to.

The OpenSearch Dashboards page is the same, but the distribution builds are for OpenSearch Dashboards instead of OpenSearch.

## Performance Test Page

On every page load, the page will make an API call the the Jenkins perf test page to get the latest 10 perf tests numbers. It will check if the folder with that number name exists:

- If doesn't exist: It will create this number folder, create the link to the performance test json, download this json to a folder(adding some properties to the json for later display), and cache it into the number folder. It will then read from this file and display information from it.

- If exists: It will read from the json and display information.

There is a JS script controlling the functionality of the compare buttons, `public/js/compare.js`.


## Integ/BWC

### OpenSearch

Every call to the Integ page will parse the Jenkins Pipeline Steps html for each integ test, x64 and arm64, if they exist. The Integ page takes the integ test numbers of these two architectures to do this. The application uses regex to find which components failed and finished, and uses this to tell which components succeeded or failed.

To generate the logs, the application reads from the cached testManifest.yml file, which tells whether or not a component has with-security or without-security tests. The link is only displayed if the corresponding test is specified to exist in this file.

### OpenSearch Dashboards

Every call to the Integ page will parse the txt stdout for each integ test, x64 and arm64, and with and without security, if they exist. The Integ page takes the integ test numbers of these two architectures to do this. The application uses regex to find which components failed and succeeded.

The logs are simply links to this txt stdout file.

## Commits

Taking the list of components from buildInfo.yml, it displays all of these in a column of a table. For each component, it then takes the git repository link and commit id from the buildInfo.yml file and generates the link to the head commit of the distribution build.

## CVEs

Taking the list of components from buildInfo.yml, it displays all of these in a column of a table. For each component, it takes the mapping from advisories.js(maps repo to name on Miki's website), and creates the URL to Miki's site.

# Future Roadmap

- Database instead of caching build number folders
- Automate the deploying of code
- Add framework to code that would change the EJS automatically.



